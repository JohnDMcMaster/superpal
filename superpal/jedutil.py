#!/usr/bin/env python3
from collections import OrderedDict
import re
import glob
from PIL import Image
import os
import shutil
import math

nbits = None
imw = None
imh = None
imbits = None

def load_jed(fn):
    """
    JEDEC file generated by 1410/84 from PALCE20V8H-15 06/28/20 22:42:11*
    DM AMD*
    DD PALCE20V8H-15*
    QF2706*
    G0*
    F0*
    L00000 0000000000000000000000000100000000000000*
    """
    ret = {}
    d = OrderedDict()
    with open(fn) as f:
        li = 0
        for l in f:
            li += 1
            # remove *, newline
            l = l.strip()[0:-1]
            if not l:
                continue
            if li == 2:
                ret["description"] = l
                continue
            parts = l.split(" ")
            main_line = " ".join(parts[1:])
            if parts[0] == "DM":
                ret["vendor"] = main_line
            elif parts[0] == "DD":
                ret["part"] = main_line
            elif l[0:2] == "QF":
                ret["len"] = int(l[2:])
            elif l[0] == "L":
                # L00000 0000000000000000000000000100000000000000*
                addr, bits = l.split(" ")
                addr = int(addr[1:], 10)
                d[addr] = bits
            else:
                continue

    ret["data"] = d
    return ret

def jed2txt(jed):
    ret = ""
    for v in jed["data"].values():
        ret += v
    assert jed["len"] == nbits
    assert nbits == len(ret), (nbits, len(ret))
    return ret

def load_jed_flat(fn):
    jed = load_jed(fn)
    return jed2txt(jed)

def save_jed(jed, fn_out):
    buff = ""
    def writeline(s):
        nonlocal buff
        buff += s + "\r\n"
    # 02 => STX
    writeline("\x02")

    """
    writeline("JEDEC file generated by icfuzz*")
    writeline("DM National Semiconductor*")
    writeline("DD PAL16R8*")
    writeline("QF2048*")
    """
    writeline(jed["description"] + "*")
    writeline("DM " + jed["vendor"] + "*")
    writeline("DD " + jed["part"] + "*")
    writeline("QF%u*" % jed["len"])

    writeline("G0*")
    writeline("F0*")

    checksum = 0
    for addr, word32 in jed['data'].items():
        # writeline("L%05u %s*" % (addr, vals))
        buff += "L%05u %s*\r\n" % (addr, word32)
        word32 = word32[::-1]
        checksum = (checksum + int(word32[0:8], 2) + int(word32[8:16], 2) + int(word32[16:24], 2) + int(word32[24:32], 2)) % 0x10000

    writeline("C%04X*" % checksum)

    # 03 => ETX
    # 3.2 Computing the Transmission Checksum
    # Includes all characters include STX and ETX
    tx_csum = sum([ord(x) for x in buff]) % 0x10000
    # I messed up the TX checksum, but evidently BP ignores 0000
    tx_csum = 0
    buff += "\x03%04X" % tx_csum

    f = open(fn_out, "w").write(buff)


def make_jed_from_words(words):
    """
    00000000  02 0d 0a 4a 45 44 45 43  20 66 69 6c 65 20 67 65  |...JEDEC file ge|

    JEDEC file generated by 1410/84 from PAL16R8A2 01/18/21 01:02:38*
    DM National Semiconductor*
    DD PAL16R8A2*
    QF2048*
    G0*
    F0*
    L00000 11111111111111111111111111111111*
    L00032 11111111111111111111111111111111*
    L00064 10000000000000000000000000000000*
    ...
    # 02 => STX
    """
    ret = """\
\x02\r\n\
JEDEC file generated by 1410/84 from PAL16R8A2 01/18/21 01:02:38*\r\n\
DM National Semiconductor*\r\n\
DD PAL16R8A2*\r\n\
QF2048*\r\n\
G0*\r\n\
F0*\r\n\
"""
    wordi = 0
    checksum = 0
    for addr in range(0, 32 * 64, 32):
        # L00032 11111111111111111111111111111111*
        # print(addr, wordi)
        word32 = words[wordi]
        if type(word32) is list:
            word32 = ''.join(word32)
        assert len(word32) == 32
        ret += "L%05u %s*\r\n" % (addr, word32)
        word32 = word32[::-1]
        checksum = (checksum + int(word32[0:8], 2) + int(word32[8:16], 2) + int(word32[16:24], 2) + int(word32[24:32], 2)) % 0x10000
        wordi += 1

    # 16 bit sum (truncated) of the 8 bit fields
    # checksum = 0
    ret += "C%04X*\r\n" % checksum
    # 03 => ETX
    # 3.2 Computing the Transmission Checksum
    # Includes all characters include STX and ETX
    tx_csum = sum([ord(x) for x in ret]) % 0x10000
    # I messed up the TX checksum, but evidently BP ignores 0000
    tx_csum = 0
    ret += "\x03%04X" % tx_csum

    return ret

